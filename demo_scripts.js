var features_demos = new Map([["CHOOSE A DEMO...", "# Welcome to MicroPython on Unicorn!\n\n# The terminal beside this is no ordinary REPL.\n# It utilizes the Unicorn CPU emulator converted\n# to Javascript by Unicorn.js in order to run MicroPython\n# \"bare metal\" on an ARM CPU emulation. The user and reset buttons along with the LEDs and pins\n# on the pyboard below are fully functional. Unfortunately\n# that's not quite the case for the clock speed approximation\n# when delayed.\n\n# Try to write a script, paste some code or run a demo!\n"], ["HELLO WORLD!", "# hello world!\nprint('hello world')\n"], ["BIG INTEGER", "# bignum\nprint(1 << 1000)\n"], ["ASSEMBLY", "# inline assembler\n@micropython.asm_thumb\ndef asm_add(r0, r1):\n    add(r0, r0, r1)\nprint(asm_add(1, 2))\n"], ]);
var pyboard_demos = new Map([["CHOOSE A DEMO...", "# Welcome to MicroPython on Unicorn!\n\n# The terminal beside this is no ordinary REPL.\n# It utilizes the Unicorn CPU emulator converted\n# to Javascript by Unicorn.js in order to run MicroPython\n# \"bare metal\" on an ARM CPU emulation. The user and reset buttons along with the LEDs and pins\n# on the pyboard below are fully functional. Unfortunately\n# that's not quite the case for the clock speed approximation\n# when delayed.\n\n# Try to write a script, paste some code or run a demo!\n"], ["HELLO WORLD!", "# hello world!\n\nprint('hello world')\n"], ["BIG INTEGER", "# bignum\n\nprint(1 << 1000)\n"], ["ASSEMBLY", "# inline assembler\n\n@micropython.asm_thumb\ndef asm_add(r0, r1):\n    add(r0, r0, r1)\nprint(asm_add(1, 2))\n"], ["SWITCH", "# push the USR button on the pyboard to flash the LEDs!\n# try using the reset button on the pyboard to quit this script!\n# switch callback not yet supported.\n\nimport time\nimport pyb\n\nwhile True:\n    if pyb.Switch().value():\n        pyb.LED(1).on()\n    else:\n        pyb.LED(1).off()\n    time.sleep_ms(50)\n\n"], ["LEDS", "# four LEDS numbered 1 to 4\n\nimport time\nimport pyb\n\nfor i in range(1000):\n    pyb.LED((i%4) + 1).toggle()\n    time.sleep_ms(100)\n"], ["TIME", "# the time module is utime, a specialized MicroPython library\n# sleep will break the clock speed\n# dates not yet supported\n\nimport time\n\nprint(time.ticks_ms())\n\ntime.sleep_ms(1000)\n\nprint(time.ticks_us())\n\ntime.sleep_us(1000000)\n"], ["MATH", "# a subset of the Python Math library\n\nimport math\nimport cmath\n\nprint(math.sqrt(5))\nprint(math.log10(100))\nprint(math.sin(12345) ** 2 + math.cos(12345) ** 2)\nprint(math.cosh(1) ** 2 - math.sinh(1) ** 2)\nprint(cmath.polar(1 + 1j))\n"], ["PIN LED", "# PERIPHERALS: pin_led\n# Using a Pin with micropython\n# Make sure you have the LED checkbox marked!\n\nimport machine\n\n# The LED is connected to our virtual pin Y12\ny12 = machine.Pin('Y12')\n\ny12(0 if y12() else 1)\n"], ["ADC", "# PERIPHERALS: pin_adc\n# Using the ADC (Analogue to Digital Converter)\n# Make sure you have the ADC checkbox marked!\n\nimport machine\nimport pyb\n\n# The slider is connected to pin Y4, try adjusting it\ny4 = machine.Pin('Y4')\n\nadc = pyb.ADC(y4)\n\nprint(adc.read())\n"], ["SERVO", "# PERIPHERALS: pin_servo\n# Using the Servo\n# Make sure you have the Servo checkbox marked!\n\nimport machine\nimport pyb\n\n# The pyboard has four simple servo connections\nservo = pyb.Servo(1)\n\nservo.angle(90, 5000)\n"], ["I2C LCD", "# PERIPHERALS: i2c_lcd\n# A fully simulated I2C bus and LCD Display\n# The framebuf class simplifies graphics in MicroPython\n# Use the hardware i2c in example Pong for faster performance\n# Make sure you have the I2C LCD checkbox marked!\n\nimport machine\nimport framebuf\n\nscl = machine.Pin('X9')\nsda = machine.Pin('X10')\ni2c = machine.I2C(scl=scl, sda=sda)\n\nfbuf = framebuf.FrameBuffer(bytearray(64 * 32 // 8), 64, 32, framebuf.MONO_HLSB)\n\nlogo = framebuf.FrameBuffer(bytearray(17 * 17 // 8), 17, 17, framebuf.MONO_HLSB)\n\nlogo.fill(0)\nlogo.fill_rect(1, 1, 15, 15, 1)\nlogo.vline(4, 4, 12, 0)\nlogo.vline(8, 1, 12, 0)\nlogo.vline(12, 4, 12, 0)\nlogo.vline(14, 13, 2, 0)\n\nfbuf.fill(0)\nfbuf.blit(logo, 23, 7)\n\ni2c.writeto(8, fbuf)\n"], ["MANDELBROT SET", "# A python Mandelbrot set courtesy of \n# http://warp.povusers.org/MandScripts/python.html\n# Try your own Python3 scripts on MicroPython!\n\nminX = -2.0\nmaxX = 1.0\nwidth = 60\nheight = 28\naspectRatio = 2\n\nchars = ' .,-:;i+hHM$*#@ '\n\nyScale = (maxX-minX)*(float(height)/width)*aspectRatio\n\nfor y in range(height):\n    line = ''\n    for x in range(width):\n        c = complex(minX+x*(maxX-minX)/width, y*yScale/height-yScale/2)\n        z = c\n        for char in chars:\n            if abs(z) > 2:\n                break\n            z = z*z+c\n        line += char\n    print(line)\n"], ["Pong", "# PERIPHERALS: i2c_lcd pin_adc\n# Pong!\n# Using emulated hardware i2c, we can push enough frames for\n# rough animations. Performance for this project is reduced\n# using chromium.\n\nimport machine\nimport framebuf\nimport time\nimport pyb\n\nSCREEN_WIDTH = 64\nSCREEN_HEIGHT = 32\n\ngame_over = False\nscore = 0\n\nclass Entity:\n    def __init__(self, x, y, w, h, vx, vy):\n        self.x = x;\n        self.y = y;\n        self.w = w;\n        self.h = h;\n        self.vx = vx;\n        self.vy = vy;\n\n    def draw(self, fbuf):\n        fbuf.fill_rect(int(self.x), int(self.y), self.w, self.h, 1)\n\nclass Ball(Entity):\n    def update(self, dt, player):\n        self.x += self.vx * dt;\n        if (self.x <= 0):\n            self.x = 0\n            self.vx = -self.vx\n        if (self.x >= SCREEN_WIDTH - self.w):\n            self.x = SCREEN_WIDTH - self.w\n            self.vx = -self.vx\n        self.y += self.vy * dt;\n        if (self.y <= 0):\n            self.y = 0\n            self.vy = -self.vy\n        if (self.y >= SCREEN_HEIGHT - self.h - player.h):\n            if (self.x >= player.x and self.x <= player.x + player.w):\n                self.y = SCREEN_HEIGHT - self.h - player.h\n                self.vy = -self.vy\n                global score\n                score += 1\n                if score % 2 == 0:\n                    self.vx += (self.vx/abs(self.vx)) * 1\n                if score % 3 == 0:\n                    self.vy += (self.vy/abs(self.vy)) * 1\n            else:\n                global game_over\n                game_over = True\n\nclass Player(Entity):\n    pass\n\nball = Ball(32, 16, 1, 1, 2, -2)\nplayer = Player(30, 31, 10, 1, 0, 0)\n\ny4 = machine.Pin('Y4')\nadc = pyb.ADC(y4)\ni2c = machine.I2C('X')\nfbuf = framebuf.FrameBuffer(bytearray(64 * 32 // 8), 64, 32, framebuf.MONO_HLSB)\ntick = time.ticks_ms()\n\nwhile not game_over:\n    ntick = time.ticks_ms()\n    ball.update(time.ticks_diff(ntick, tick) // 100, player)\n    tick = ntick\n    player.x = adc.read() * 58 / 255\n    fbuf.fill(0)\n    ball.draw(fbuf)\n    player.draw(fbuf)\n    i2c.writeto(8, fbuf)\n    time.sleep_ms(50) # Adjust this for performance boosts\n\nfbuf.fill(0)\nfbuf.text('GAME', 15, 8)\nfbuf.text('OVER', 15, 18)\ni2c.writeto(8, fbuf)\n\nprint('Score: ', score)\n"], ]);
var minimal_demos = new Map([["CHOOSE A DEMO...", "# Welcome to MicroPython on Unicorn!\n\n# The terminal beside this is no ordinary REPL.\n# It utilizes the Unicorn CPU emulator converted\n# to Javascript by Unicorn.js in order to run MicroPython\n# \"bare metal\" on an ARM CPU emulation. The user and reset buttons along with the LEDs and pins\n# on the pyboard below are fully functional. Unfortunately\n# that's not quite the case for the clock speed approximation\n# when delayed.\n\n# Try to write a script, paste some code or run a demo!\n"], ["HELLO WORLD!", "# hello world!\nprint('hello world')\n"], ]);
